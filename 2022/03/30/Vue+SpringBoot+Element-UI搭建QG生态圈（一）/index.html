<!DOCTYPE html><html lang="cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SpringBoot+Vue+Element-UI搭建前后端分离项目QG生态圈（一）"><meta name="keywords" content="全栈"><meta name="author" content="WiKim"><meta name="copyright" content="WiKim"><title>SpringBoot+Vue+Element-UI搭建前后端分离项目QG生态圈（一） | WiKim's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text"> 登录流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springsecurity%E8%AE%A4%E8%AF%81"><span class="toc-number">2.</span> <span class="toc-text"> SpringSecurity认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8springsecurity%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 使用SpringSecurity实现登录流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#service%E5%B1%82%E7%9A%84login%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text"> Service层的login接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E6%9C%AA%E7%99%BB%E5%BD%95%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 拦截未登录请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text"> 效果展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%98%AFpostman"><span class="toc-number">3.1.</span> <span class="toc-text"> 首先是PostMan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%B6%E5%90%8E%E6%98%AF%E5%89%8D%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text"> 然后是前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91"><span class="toc-number">3.3.</span> <span class="toc-text"> 一些踩坑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 跨域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220125231602653.png"></div><div class="author-info__name text-center">WiKim</div><div class="author-info__description text-center">爬虫爱好者</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/wkml">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220126005934337.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">WiKim's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">SpringBoot+Vue+Element-UI搭建前后端分离项目QG生态圈（一）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-30</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.7k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>消失了一段时间，这段时间在转后台，简单介绍一下这个项目产生的原因吧。</p>
<span id="more"></span>
<p>学后台两个月了，还没写过项目，学了springboot之后兴致勃勃地想要写一个项目来练练手，这里就直接用后台组的考核来练练手，采用vue+springboot前后端分离的方式来进行开发。</p>
<p>出于对考核的保密，先不介绍整个项目的结构了，就慢慢写吧，反正等我写出来了，差不多后台组考核也公布了，希望能基本把每个模块的开发流程都写下来hhh。</p>
<p>这篇先写登录的流程，而且只讲后台（实际上前端花了更多时间啊草），使用SpringSecurity来完成整个过程。</p>
<p><strong>预备知识：</strong></p>
<p><strong>SpringBoot</strong></p>
<p><strong>Mybatis-plus</strong></p>
<p><strong>Redis</strong></p>
<p><strong>Jwt认证</strong></p>
<h2 id="登录流程"><a class="markdownIt-Anchor" href="#登录流程"></a> 登录流程</h2>
<p>现在工作室做的前后端分离项目都是采用token进行验证登录状态的，对比Session可以解决分布式环境下的问题，于是我也去学了一下token登录的流程，过程如下：</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330202713377.png" alt="" /></p>
<p>简单复述下流程：</p>
<ul>
<li>前端调用登录接口将username和password传给后台</li>
<li>后台在数据库中查找对应的用户</li>
<li>如果查找成功，那么用jwt工具通过UserID生成一个token，同时采用缓存存放登录的用户信息-</li>
<li>将token返回给前端，前端保存在cookies或localstorge中</li>
<li>以后前端每次发送请求时，将token携带在header中</li>
<li>后台对前端携带的token进行解析，如果解析成功，那么允许该请求，否则，返回失败信息</li>
</ul>
<p>还有一个比较详细的版本：</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B2.png" alt="登录流程2" /></p>
<p>不过很多人都说token不存在缓存里，所以我也不把token存在缓存里，而是将采用<strong>将登录的用户的信息存放在redis</strong>的方式。</p>
<p>下面记录一下怎么使用SpringSecurity完成上面的流程。</p>
<h2 id="springsecurity认证"><a class="markdownIt-Anchor" href="#springsecurity认证"></a> SpringSecurity认证</h2>
<p>SpringSecurity擅长的两件事：认证和授权，而且有一个核心的<strong>上下文对象Authentication</strong>，采用一系列过滤器链来处理程序可能出现的安全问题（虽然但是，真的比原生难用好多），为此，我也是学了好几天的SpringSecurity的过滤器链，在登录流程中，最关键的几个是：</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png" alt="过滤器链" /></p>
<ul>
<li>
<p>首先是UsernamePasswordAuthenticationFilter，它负责<strong>处理我们在登录页面填写了用户名和密码之后的登录请求</strong>，可以说是整个流程的核心，在Security中他的默认实现是采用从内存中读取Password的方式。</p>
</li>
<li>
<p>然后是ExceptionTranslationFilter，负责处理过滤器链中抛出的异常，用来处理各种错误情况。</p>
</li>
<li>
<p>最后是FilterSecurityInterceptor，负责权限的校验，这个我暂时还没碰到（权限还没开始写）。</p>
</li>
</ul>
<h3 id="使用springsecurity实现登录流程"><a class="markdownIt-Anchor" href="#使用springsecurity实现登录流程"></a> 使用SpringSecurity实现登录流程</h3>
<h4 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h4>
<p>整个登录的SpringSecurity的流程图如下：</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/%E6%B5%81%E7%A8%8B%E5%9B%BE2.png" alt="流程图2" /></p>
<p>（比较糊，因为是偷的…</p>
<p>其中最关键的是最后的的这个流程，就是进行密码的校验，其中调用了<code>UserDetailsService</code>的实现类，而上面讲过，在原始的实现中，Security是在内存中随机生成了一个密码，如果想要通过数据库进行校验，那么就要自己实现一个<code>UserDetailsService</code>接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;MyUser&gt; queryWrapper = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(MyUser::getUsername, username);</span><br><span class="line">        <span class="comment">// 从数据库中查询出用户实体对象</span></span><br><span class="line">        MyUser user = userMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="comment">// 若没查询到一定要抛出该异常，这样才能被Spring Security的错误处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这代表查询到了实体对象，那就返回我们自定义的UserDetail对象（这里权限暂时放个空集合）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用mybatis-plus的条件构造器查询，成功之后，暂时返回一个权限集合为空的LoginUser对象，实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyUser user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有一些无所谓的getset方法</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个LoginUser实现了UserDetails，也就是上面重写的loadUserByUsername方法接受的返回类型。主要是封装了User对象，以及他可以拥有的权限，方便封装到上下文对象中。</p>
<p>做好上面的准备之后，就可以在Service层中的Login接口进行验证了！</p>
<h4 id="service层的login接口实现"><a class="markdownIt-Anchor" href="#service层的login接口实现"></a> Service层的login接口实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseResult <span class="title">login</span><span class="params">(MyUser user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将用户名和密码封装到预备对象中</span></span><br><span class="line">    UsernamePasswordAuthenticationToken authenticationToken = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword());</span><br><span class="line">    <span class="comment">// 这一步是校验，会调用上面自己实现的UserDetailsServiceImpl</span></span><br><span class="line">    Authentication authenticate = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">    <span class="comment">// 如果密码对不上，抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(authenticate)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果认证通过了，使用userid生成一个jwt jwt存入ResponseResult返回</span></span><br><span class="line">    LoginUser loginUser = (LoginUser) authenticate.getPrincipal();</span><br><span class="line">    String userId = loginUser.getUser().getId().toString();</span><br><span class="line"></span><br><span class="line">    JwtManager jwtManager = <span class="keyword">new</span> JwtManager();</span><br><span class="line">    String jwt = jwtManager.generate(userId);</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;useranme&quot;</span>, user.getUsername());</span><br><span class="line">    map.put(<span class="string">&quot;token&quot;</span>, jwt);</span><br><span class="line">    <span class="comment">//把完整的用户信息存入redis  userid作为key</span></span><br><span class="line">    redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span> + userId, loginUser);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult(<span class="number">200</span>, <span class="string">&quot;登录成功&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我是使用UserId生成一个Token，封装在自己写的Response对象中，返回给前端。jwt工具类网上cv了一个hhh</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String secretKey = <span class="string">&quot;qg_Ecosphere&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间目前设置成2天，这个配置随业务需求而定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Duration expiration = Duration.ofDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 过期时间</span></span><br><span class="line">        Date expiryDate = <span class="keyword">new</span> Date(System.currentTimeMillis() + expiration.toMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 将用户id放进JWT</span></span><br><span class="line">                .setSubject(userId)</span><br><span class="line">                <span class="comment">// 设置JWT签发时间</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date())</span><br><span class="line">                <span class="comment">// 设置过期时间</span></span><br><span class="line">                .setExpiration(expiryDate)</span><br><span class="line">                <span class="comment">// 设置加密算法和秘钥</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secretKey)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token JWT字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析成功返回Claims对象，解析失败返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">parse</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是空字符串直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Claims claims = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 解析失败了会抛出异常，所以我们要捕捉一下。token过期、token非法都会导致解析失败</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secretKey)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;token解析失败:&#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这些之后，Controller层调用Service的login接口，就可以实现登录了！</p>
<p>接下来的工作是，拦截未登录的请求。</p>
<h4 id="拦截未登录请求"><a class="markdownIt-Anchor" href="#拦截未登录请求"></a> 拦截未登录请求</h4>
<p>这里自己继承一个拦截器LoginFilter，而且继承的是Spring自带的OncePerRequestFilter，主要是为了保证一次请求只会经过一次拦截器。</p>
<p>主要的流程都在代码里了，感觉还是很清晰的~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtManager jwtManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 从请求头中获取token字符串并解析</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">// 检查有无token，如果没有的话直接放行</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试解析token</span></span><br><span class="line">            Claims claims = jwtManager.parse(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 解析失败</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;token非法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询出用户对象</span></span><br><span class="line">        String redisKey = <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        <span class="comment">// 如果缓存中不存在，可能过期</span></span><br><span class="line">        LoginUser loginUser = redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 手动组装一个认证对象</span></span><br><span class="line">        <span class="comment">//TODO 注入权限</span></span><br><span class="line">        UsernamePasswordAuthenticationToken authentication =</span><br><span class="line">                <span class="keyword">new</span> UsernamePasswordAuthenticationToken(loginUser, <span class="keyword">null</span>, loginUser.getAuthorities());</span><br><span class="line">        <span class="comment">// 将认证对象放到上下文中</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等，是不是还有什么事情忘了？我们还得注意把这个过滤器注册到容器中，而且要注册到正确的位置！如果是在整个原生过滤器链的最后才插入了这个过滤器，那就没什么意义了。SpringSecurity为我们提供了一个接口，让我们能将任意的（也许吧）过滤器注入到任意的（也许吧）原生过滤器的任意位置！<code>http.addFilterBefore(loginFilter, UsernamePasswordAuthenticationFilter.class);</code>在Security的配置类中，可以使用这段代码，将我们自定义的LoginFilter注入到UsernamePasswordAuthenticationFilter之前。</p>
<p>上面的这些都是我们在配合SpringSecurity进行配置，最后需要做的就是让我们上面的配置生效！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我们采用继承WebSecurityConfigurerAdapter类的方式，来让全局配置生效</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginFilter loginFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 禁用session</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 这是配置的关键，决定哪些接口开启防护，哪些接口绕过防护</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定某些接口不需要通过验证即可访问。登陆、注册接口肯定是不需要认证的</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/user/register&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 这里意思是其它所有接口需要认证才能访问</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加我们自己的过滤器</span></span><br><span class="line">        http.addFilterBefore(loginFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置异常处理器</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">                <span class="comment">//配置认证失败处理器</span></span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint);</span><br><span class="line">        <span class="comment">// 允许跨域</span></span><br><span class="line">        http.cors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们上面配置了许多的配置，在这里需要重写这方法，代表采用我们自己的配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationManager <span class="title">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是配置密码加密器，SpringSecurity对安全要求很严格</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，完成上面这些流程之后，接下来看看请求接口的效果！</p>
<h2 id="效果展示"><a class="markdownIt-Anchor" href="#效果展示"></a> 效果展示</h2>
<h3 id="首先是postman"><a class="markdownIt-Anchor" href="#首先是postman"></a> 首先是PostMan</h3>
<p>先在没登录前请求一次数据</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330214320089.png" alt="image-20220330214320089" /></p>
<p>OK，显示让我们登录，那我们进行登录</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330214334684.png" alt="image-20220330214334684" /></p>
<p>登陆成功了，把token放到header里面，再请求一次</p>
<p><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330214348122.png" alt="image-20220330214348122" /></p>
<p>成功返回数据！</p>
<h3 id="然后是前端"><a class="markdownIt-Anchor" href="#然后是前端"></a> 然后是前端</h3>
<center class="half">    <img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330213804500.png" width="800"/><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330213834809.png" width="800"/> </center>
<p>成功跳转了，也返回了正确的Response，OK~</p>
<h3 id="一些踩坑"><a class="markdownIt-Anchor" href="#一些踩坑"></a> 一些踩坑</h3>
<p>后台的流程看了一些材料之后就成功使用postman实现了，整个流程最阴间的部分莫过于写前端了，虽然是采用vue-admin的模板进行搭建，但是作为第一次接触前端项目，也踩了N多坑。</p>
<h4 id="跨域"><a class="markdownIt-Anchor" href="#跨域"></a> 跨域</h4>
<p>首先就是接口的对接，各种请求接收不到，疯狂跨域，最后把后台代码简单修改了一下就解决了（就是把一行代码换了位置，至今不知道为什么T-T）</p>
<p>然后就是一些vue的各种离奇错误，但是在春咩的悉心指导下，也得到解决了~</p>
<center class="half">    <img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330215229318.png" width="200"/><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330215241319.png" width="200"/><img src="http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220330215236142.png" width="200"/> </center>
<p>下一期写一下其他的接口和前端的实现吧！学无止境~</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p>SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权-B站最通俗易懂的Spring Security课程</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mm4y1X7Hc">https://www.bilibili.com/video/BV1mm4y1X7Hc</a></p>
<p>流程讲得贼清楚捏，很适合入门。</p>
<p>【项目实践】一文带你搞定Spring Security + JWT实现前后端分离下的认证授权</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342755411">https://zhuanlan.zhihu.com/p/342755411</a></p>
<p>和上面的教程差不多，思路也挺清晰的。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WiKim</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wkml.github.io/2022/03/30/Vue+SpringBoot+Element-UI搭建QG生态圈（一）/">https://wkml.github.io/2022/03/30/Vue+SpringBoot+Element-UI搭建QG生态圈（一）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%A8%E6%A0%88/">全栈</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/01/30/asyncio+aiohttp+xpath%E5%BC%82%E6%AD%A5%E7%88%AC%E5%8F%96%E6%A2%A8%E8%A7%86%E9%A2%91%E9%A6%96%E9%A1%B5%E8%A7%86%E9%A2%91/"><span>asyncio+aiohttp+xpath异步爬取梨视频首页视频</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == 'true';
var verify = 'true' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'StIxiMKtozmPuIHapkJ7jNbk-gzGzoHsz',
  appKey:'eMvmCoAklkJSs3pxwG4UzsG5',
  placeholder:'发表你的友善见解OvO！（输入上面的邮箱可以收到别人对你最新回复哦！）',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(http://aliyun-wkml.oss-cn-beijing.aliyuncs.com/img/image-20220126005934337.png)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By WiKim</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这里是wk的个人博客！</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>